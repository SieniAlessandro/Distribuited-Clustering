package it.unipi.cds.federatedLearning.node;

import java.util.Random;
import java.util.concurrent.TimeUnit;

import it.unipi.cds.federatedLearning.Config;

/**
 * This class is used to simulate the data generated by the sensors: to simulate the data generated
 * we have used two IID Gaussian distribution (seeded with two different seeds); to simulate the
 * interarrivals of the data we use an Exponential distribution IID for each sensor with a constant mean rate
 * 
 */
public class DataGenerator implements Runnable{
	
	private RepositoryHandler repository = null;
	/*
	 * Used to have an exponential distribution of the interarrivals of the data collected
	 * exponentialSeed is used to generate a uniform distribution between 0 and 1
	 * lambda is used as the mean rate of arrival of a message
	 */
	private Random exponentialSeed; 
	private double lambda = 0.9;

	/*
	 * Used to have a fixed number of writes
	 */
	private int numberOfWrites;
	/*
	 * Used to have infiniteWrites
	 */
	private Boolean infiniteWrites;
	
	/**
	 * Constructor initializes the basic attributes and generate and create the exponentialSeed with a unique seed each time that is called
	 * @param repository The object used to write in a concurrent way in the repository
	 * @param numberOfWrites The max number of write cycles that the thread have to do
	 * @param infiniteWrites Parameter used to perform an infinite cycle
	 */
	public DataGenerator(RepositoryHandler repository, int numberOfWrites, Boolean infiniteWrites) {
		this.repository = repository;
		this.numberOfWrites = numberOfWrites;
		this.infiniteWrites = infiniteWrites;
		this.exponentialSeed  = new Random();
	}

	/**
	 * Here we generate the Gaussian distributions and in a loop after the exponential delay it simulates the sending of the data
	 */
	public void run(){
		Random gaussianX = new Random();
		Random gaussianY = new Random();
				
		for (int i = 0; i < numberOfWrites || infiniteWrites; i++) {
			double delay = getNextExponentialDelay() + 1.0;

			try {
				TimeUnit.SECONDS.sleep((long) delay);
			} catch (InterruptedException ex) {
				System.err.println(Thread.currentThread().getName() + " has been interrupted!");
				Thread.currentThread().interrupt();
			}
			Double sensedDataX = gaussianX.nextGaussian();
			Double sensedDataY = gaussianY.nextGaussian();
			sensedDataX *= Config.ST_DEV;
			sensedDataY *= Config.ST_DEV;
			if(Thread.currentThread().getId()%2 == 0) {
				sensedDataX += Config.MEAN;
				sensedDataY += Config.MEAN;
			}else {
				sensedDataX -= Config.MEAN;
				sensedDataY -= Config.MEAN;
			}
			
			
			try {
				repository.write(sensedDataX, sensedDataY);
			} catch (InterruptedException e) {
				System.err.println(e.getMessage());
			}
		}
	}
	
	/**
	 * Used to generate a real exponential distribution starting from a Uniform distribution (exponentialSeed) with a mean value of lambda
	 * @return the simulated time necessary to the sensor to sense the data
	 */
	public double getNextExponentialDelay() {
	    double result =  Math.log(1-exponentialSeed.nextDouble())/(-lambda);
	    if(result < 0)
	    	result = -result;
	    return result;
	}



}
