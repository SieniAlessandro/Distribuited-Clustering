package it.unipi.cds.federatedLearning.node;

import it.unipi.cds.federatedLearning.Config;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.atomic.*;

/**
 * This class is used as a receiver of the data generated by the simulated sensors, it handles
 * the concurrency of the writes with a Fair Lock and start the ModelCaller to perform the REST request when it is necessary
 *
 */
public class RepositoryHandler {

	/*
	 * The first time the Machine Learning algorithm will be called only if there are a number of values higher than a certain threshold
	 */
	private int threshold; 
	/*
	 * Used to know how many values were stored when the ML was called the last time
	 */
	private int oldNumberOfSamples = 0; 
	/*
	 * When we have a number of data higher than the threshold, ML called when there are a certain number of new values
	 */
	private AtomicInteger newValues = new AtomicInteger(0); 
	/*
	 * Used to store the actual number of values
	 */
	private static AtomicInteger numberOfSamples = new AtomicInteger(0); 

	/*
	 * Constants used to store the files path
	 */
	private final String samplePath = Config.PATH_NODE_COLLECTED_DATA+ DataCollector.nodeCommunicationHandler.getNodeID()+ ".txt";
	private final String readySamplesPath = Config.PATH_NODE_READY_DATA+ DataCollector.nodeCommunicationHandler.getNodeID()+ ".txt";
	
	
	/*
	 * Variables used to manage concurrency with a FairLock implementation
	 */
	private boolean isLocked = false;
	private Thread lockingThread = null;
	private List<String> waitingThreads = new ArrayList<>();

	/**
	 * Constructor of the class, it sets its attributes, and check if the directory used to store the data exist, if not it is created, with the necessary files
	 * @param threshold integer used as first threshold to decide when the machine learning must be started
	 * @param newValues integer used after threshold, it represents the number of new values, from the 
	 * moment the machine learning has being called, necessary to start again the machine learning
	 */
	public RepositoryHandler(int threshold) {
		this.threshold = threshold;
		this.oldNumberOfSamples = 0;
		try {
				File folder = new File(Config.PATH_NODE_BASEDIR);
				if(!folder.exists())
					folder.mkdir();
				File cd = new File(samplePath);
				File rd = new File(readySamplesPath);
				if(!cd.exists())
					cd.createNewFile();
				if(!rd.exists())
					rd.createNewFile();
		}catch(IOException e) {
			System.out.println(e.getMessage());
			return;
		}
	}
	
	/**
	 * Lock used for the Fair Lock, if the lock is free or the thread is at the beginning of the queue
	 * used for the implementation of the Fair Lock, then the current thread can get the lock, otherwise it
	 * must wait its turn
	 * @throws InterruptedException because it is used the function Thread.wait()
	 */
	public void lock() throws InterruptedException{
		
		String activeThread = Thread.currentThread().getName();
		
		synchronized(this) {
			waitingThreads.add(activeThread);
			while(isLocked || waitingThreads.get(0) != activeThread) {
				synchronized(activeThread) {
					try {
						activeThread.wait();
					}catch(InterruptedException e){
						waitingThreads.remove(activeThread);
						throw e;
					}
				}
			}
			waitingThreads.remove(activeThread);
			isLocked = true;
			lockingThread = Thread.currentThread();
		}
	}
	
	/**
	 * Unlock used for the Fair Lock, here the current thread check if it has the lock and if it 
	 * has the lock, the current thread proceeds to release it, otherwise it throws an IllegalMonitorStateException
	 * @throws IllegalMonitorStateException when a lock that has not get the lock tries to release it
	 */
	public void unlock() {
		if(!isLocked || this.lockingThread != Thread.currentThread()) {
			throw new IllegalMonitorStateException("Calling thread has not locked this lock");
		}
		this.isLocked = false;
		lockingThread = null;
		if(waitingThreads.size() > 0) {
			String sleepingThread = waitingThreads.get(0);
			synchronized (sleepingThread) {
				sleepingThread.notify();
			}
		}
	}
	
	/**
	 * Function used to simulate the reception of the data from a sensor node. Here we use
	 * the Fair Lock to handle the concurrency of the write operations in a single file.
	 * If the number of values written is above the threshold then we call the read.
	 * @param sensedDataX first value sensed of the pair of value sensed
	 * @param sensedDataY second value sensed of the pair of value sensed
	 * @throws InterruptedException because of the lock function
	 */
	public void write(Double sensedDataX, Double sensedDataY) throws InterruptedException{
		
		this.lock();
				
		int instantNumberOfSamples = numberOfSamples.incrementAndGet();
		
		try(
			FileWriter fw = new FileWriter(samplePath, true);
				)
		{
			fw.append(sensedDataX.toString() + "," + sensedDataY.toString() + "\n");
		}catch(IOException e) {
			System.out.println(e.getMessage());
			return;
		}
		
		if(!DataCollector.aModelIsBeingGeneratedNow) {
			int value = newValues.get();
			if((oldNumberOfSamples == 0 && instantNumberOfSamples >= threshold) 
					|| (oldNumberOfSamples > 0 && instantNumberOfSamples - oldNumberOfSamples >= value)
			){
				DataCollector.aModelIsBeingGeneratedNow = true;
				if(oldNumberOfSamples == 0) {
					this.read(threshold);
				}
				else {
					this.read(value);
				}
				oldNumberOfSamples = instantNumberOfSamples;
			}
		}
		this.unlock();
	}
	
	/**
	 * Function used to read and move the value stored from the sensors to another file that will be used
	 * by the machine learning algorithm, this is made to avoid the fact that new values can arrive while the
	 * machine learning algorithm is working, and for all the new value we must check before starting the algorithm
	 * if it is an outlier or not. After moving the data it starts ModelCaller
	 * @param valuesToRead used to specify the actual number of values inside the file used to store the data from the sensors
	 *
	 */
	private void read(int valuesToRead){
		try(FileWriter fw = new FileWriter(readySamplesPath, true);
				){
	
			String readyData = new String (Files.readAllBytes(Paths.get(samplePath)));
			
			if(oldNumberOfSamples == 0)
				fw.write(readyData);
			else
				fw.append(readyData);
			/*
			 * Call the function to send the synchronous REST request
			 */
			Runnable caller = new ModelCaller(valuesToRead);
			new Thread(caller).start();
			newValues.set((int) (numberOfSamples.get()*Config.PERCENTAGE_OLD_VALUES));
			//We flush the file with the sample not ready to reduce redundancy of the data
			try(FileWriter fw2 = new FileWriter(samplePath);){
				fw2.write("");
			}catch(IOException ex) {
				System.out.println(ex.getMessage());
			}
				
		}catch(IOException e) {
			System.out.println(e.getMessage());
		}
	
	}
}